
<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <title>Circle with coordinates around point on map. - jsFiddle demo</title>
      <link rel="stylesheet" type="text/css" href="http://cdn.leafletjs.com/leaflet-0.6.2/leaflet.css">
      <script type='text/javascript' src="leaflet-src.js"></script>
      <script type='text/javascript' src="distance.js"></script>
    <script type='text/javascript' src="Marker.Text.js"></script>
    <style type="text/css">
        .label {
            margin-top: 0px !important;
            font-size: 6px !important;

        }
    </style>
</head>
<body>
	  <div id="map" style="width: 800px; height: 600px"></div>
	  <a href="http://leafletjs.com/reference.html">Leaflet-JS documentation</a>
<script type='text/javascript'>

map = L.map('map').setView(points[100].coord, 12);
//L.tileLayer('http://{s}.tile.cloudmade.com/BC9A493B41014CAABB98F0471D759707/997/256/{z}/{x}/{y}.png', {
    //L.tileLayer('http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
//    maxZoom: 18
//}).addTo(map);

var DEBUG = true;
var markers = [];
var poly = {};

function clearMarks(){
    markers.forEach(function(m){map.removeLayer(m)});
    markers = [];
}
function mark(point, radius, color)
{
    var m = L.circleMarker(point,{color: color, radius: radius}).addTo(map);
    markers.push(m);
}

function drawHull(hull, map){
    map.removeLayer(poly);
    poly = L.polyline(hull, {color: 'red'}).addTo(map);
}


////////////////////////////////////////////////
Array.prototype.getUnique = function(){
        var u = {}, a = [];
        for(var i = 0, l = this.length; i < l; ++i){
            if(u.hasOwnProperty(this[i].toString())) {
                continue;
            }
            a.push(this[i]);
            u[this[i].toString()] = 1;
        }
        return a;
    }

    Array.prototype.findMinYPoint = function(){
        var minI = this.length;
        var min = 360;
        for(i = 0; i < this.length; i++) {
            if(min > this[i].lat){
                min = this[i].lat;
                minI = i;
            }
        }
        return this[minI];
    }
    Array.prototype.removeByIndex = function(i){
        this.splice(i, 1);
    }

    Array.prototype.remove = function(obj){
        this.splice(this.indexOf(obj), 1);
    }

    //var prevPoint;
    var prevAngle;
    L.LatLng.prototype.angleTo = function(point){
        return -Math.atan2(this.lat - point.lat , this.lng - point.lng);
    }
    var angles = [];
    Array.prototype.sortByAngle = function (point){
        angles = [];
        this.sort(function(a,b){
              return point.angleTo(b) - point.angleTo(a);
        });
        for(i = 0; i < this.length; i++)
            angles.push(this[i].name + ': '+ point.angleTo(this[i])*180/Math.PI+'Â°')
    }

    L.LatLng.prototype.nearestPoints = function(points, count){
        var /* L.LatLng */ source = this;
        points.sort(function(a, b){
            return source.distanceTo(a) - source.distanceTo(b)
        });
        return points.slice(0, count);
    }

    Array.prototype.pointInPolygon = function (point) {
        // (c) https://github.com/substack/point-in-polygon
        // ray-casting algorithm based on
        // http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html
        var x = point.lat, y = point.lng;
        var inside = false;
        for (var i = 0, j = this.length - 1; i < this.length; j = i++) {
            var xi = this[i].lat, yi = this[i].lng;
            var xj = this[j].lat, yj = this[j].lng;
            var intersect = ((yi > y) != (yj > y))
                    && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
            if (intersect) inside = !inside;
        }
        return inside;
    };

    function intersectQ(/* LatLng */ a1, a2, b1, b2){
        //returns if segments p00-p01 and p10-p11 intersects
        if(a1 == undefined || a2 == undefined || b1 == undefined || b2 == undefined)
            return false;
        if(!(('lng' in a1) && ('lng' in a2) && ('lng' in b1) && ('lng' in b2)))
            return false;
        var x1 = a1.lng;
        var x2 = a2.lng;
        var x3 = b1.lng;
        var x4 = b2.lng;

        var y1 = a1.lat;
        var y2 = a2.lat;
        var y3 = b1.lat;
        var y4 = b2.lat;

        var x = ((x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4)) / ((x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4));
        var y = ((x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4)) / ((x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4));
        if (isNaN(x) || isNaN(y)) {
            return false;
        }
        else {
            if (x1 >= x2) {
                if (!(x2 <= x && x <= x1)) { return false; }
            }
            else {
                if (!(x1 <= x && x <= x2)) { return false; }
            }
            if (y1 >= y2) {
                if (!(y2 <= y && y <= y1)) { return false; }
            }
            else {
                if (!(y1 <= y && y <= y2)) { return false; }
            }
            if (x3 >= x4) {
                if (!(x4 <= x && x <= x3)) { return false; }
            }
            else {
                if (!(x3 <= x && x <= x4)) { return false; }
            }
            if (y3 >= y4) {
                if (!(y4 <= y && y <= y3)) { return false; }
            }
            else {
                if (!(y3 <= y && y <= y4)) { return false; }
            }
        }
        return true;
    }

    Array.prototype.concaveHull = function(k, map){
        if(k < 3)
            return [];
        var dataset = this.getUnique();
        if(this.length <= 3)
            return this;
        var kk = Math.min(k,dataset.length-1);
        var firstPoint = dataset.findMinYPoint();
        var hull = [];
        hull.push(firstPoint);
        var currentPoint  = firstPoint;
        //prevPoint = currentPoint;
        if(DEBUG) L.circleMarker(currentPoint,{color:"#F00", radius:3}).addTo(map);
        dataset.remove(firstPoint);
        prevAngle = 0;
        var step = 1;
        while (((currentPoint != firstPoint) || (step == 1)) && (dataset.length > 0)){
            if (step == 4){
                dataset.push(firstPoint)
            }
            var cPoints = currentPoint.nearestPoints(dataset,kk);
            cPoints.sortByAngle(currentPoint);
            if(DEBUG){
                clearMarks();
                for(xx=0; xx < cPoints.length; xx++)mark(cPoints[xx], 2*(xx+1), "#F0F");
            }
            var its = true;
            var i = 0;
            var j = 0;
            var lastPoint = 0;
            while (its && (i < cPoints.length)){
                if(cPoints[i] == firstPoint)
                    lastPoint = 1;
                else
                    lastPoint = 0;
                j = 1;
                its = false;
                while(!its && (j < hull.length - lastPoint)){
                    its  = intersectQ(hull[step - 1],cPoints[i], hull[step - 1 - j],hull[step - j]);
                    j++;
                }
                i++;
            }
            if(its)//since all candidates intersect at least one edge, try again with a higher number of neighbours
                return this.concaveHull(kk+1, map);
            //prevPoint = currentPoint;
            currentPoint = cPoints[i - 1];
            hull.push(currentPoint);//a valid candidate was found
            if(DEBUG) drawHull(hull, map);
            prevAngle = hull[step].angleTo(hull[step-1]);
            dataset.remove(currentPoint);
            step++;
            i++;
        }
        var allInside = true;
        i = dataset.length;
        while (allInside && i > 0) {// check if all the given points are inside the computed polygon
            i--;
            allInside = hull.pointInPolygon(dataset[i]);
        }
        if(!allInside)
            return this.concaveHull(kk+1, map); //since at least one point is out of the computed polygon, try again with a higher number of neighbours
        return hull;
    }


Array.prototype.findLeftMostLowestPoint = function(){
    var idx = 0;
    for (var i = 1; i < this.length; ++i)
    {
        var a = this[i];
        var b = this[idx];
        if(a.lng < b.lng || (a.lng == b.lng && a.lat < b.lat))
            idx = i;
    }
    return idx;
}
L.LatLng.prototype.isToLeft = function(b, c){
    var u1 = b.lng - this.lng;
    var v1 = b.lat - this.lat;
    var u2 = c.lng - this.lng;
    var v2 = c.lat - this.lat;
    return u1 * v2 - v1 * u2 < 0;
}
Array.prototype.convexHull = function(map)
{
    // Gift wrap method
    var out = [];

    var startIdx = this.findLeftMostLowestPoint();
    var hull = startIdx;

    var npts = this.length;
    var endpt = 0;
    do
    {
        out.push(this[hull]);
        if(DEBUG) drawHull(out, map);
        endpt = 0;
        for (var j = 1; j < npts; ++j)
        {
            if (hull == endpt || this[hull].isToLeft(this[endpt], this[j]))
                endpt = j;
        }
        hull = endpt;
    } while (endpt != startIdx);

    out.push(this[endpt]); // close the poly
    return out;
}


var pts = [];
for(var i = 0; i < points.length; i++){
    var p = new L.latLng(points[i].coord);
    p.name = i;
    pts.push(p);
    var pt = pts.getUnique();
}
for(i = 0; i < pts.length; i++){
    var rr = L.circleMarker(pts[i],{title:i,color:"#000", radius:1})
            .addTo(map);
    var myIcon = L.divIcon({className:'label', html:''+i});
    L.marker(pts[i], {icon: myIcon}).addTo(map);
    //var tt = new L.Marker.Text(pts[i], i).addTo(map);

}
map.fitBounds(L.polygon(pts).getBounds());
//L.polygon(pts.concaveHull(8, map), {color: "#00F", weight:1}).addTo(map);
//L.polygon(pts.convexHull(map), {color: "#00F", weight:1}).addTo(map);


</script>


</body>


</html>

